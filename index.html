<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Pro DDLC Textbox - Optimized</title>
<style>
  :root {
    --textbox-width: 900px;
    --textbox-height: 200px;
    --accent: #f6a5c0;
    --bg-color: #111;
    --text-color: #222;
  }
  html,body { height:100%; margin:0; background:var(--bg-color); color:#fff; font-family: Arial, sans-serif; overflow: hidden; }
  #scene { position: relative; width: 100vw; height: 100vh; overflow: hidden; }
  #bg {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
    z-index: 0;
    user-select: none;
    pointer-events: none;
    filter: brightness(0.95);
    background: #000;
    transition: opacity 0.5s ease;
  }
  #portrait {
    position: absolute;
    right: 40px;
    bottom: 120px;
    width: 28vw;
    max-width: 420px;
    min-width: 160px;
    z-index: 2;
    display: none;
    user-select: none;
    pointer-events: none;
  }
  #textbox {
    position: fixed;
    bottom: 0;
    left: 50%;
    transform: translateX(-50%);
    width: var(--textbox-width);
    max-width: calc(100vw - 40px);
    height: var(--textbox-height);
    max-height: 50vh;
    background: #fff;
    border-top: 6px solid var(--accent);
    box-shadow: 0 -5px 25px rgba(0,0,0,0.4);
    border-radius: 10px 10px 0 0;
    padding: 18px 22px;
    box-sizing: border-box;
    display: none;
    color: var(--text-color);
    z-index: 3;
    cursor: pointer;
  }
  #namebox {
    position: absolute;
    top: -36px;
    left: 20px;
    background: var(--accent);
    color: white;
    padding: 8px 16px;
    font-weight: bold;
    border-radius: 6px 6px 0 0;
    min-width: 80px;
    box-sizing: border-box;
    text-align: center;
  }
  #text { font-size: 22px; color: var(--text-color); line-height: 1.4; white-space: pre-wrap; word-break: break-word; max-height: calc(var(--textbox-height) - 60px); overflow:auto; }
  #next { position: absolute; bottom: 10px; right: 20px; font-size: 14px; opacity: 0.75; color: var(--text-color); user-select:none; }
  
  @media (max-width: 600px) {
    #portrait { display: none; }
    #text { font-size: 18px; }
  }
</style>
</head>
<body>

<div id="scene">
  <img id="bg" alt="background" />
  <img id="portrait" alt="character portrait" />
</div>

<div id="textbox" role="button" tabindex="0">
  <div id="namebox"></div>
  <div id="text"></div>
  <div id="next">â–¶ Click or press Space/Enter</div>
</div>

<script>
/** CONFIGURATION **/
const DIALOGUE_PATH = 'assets/dialogue.json'; 
const CHARACTERDATA_PATH = 'assets/characters/katz/characterdata.json';

/** STATE **/
let dialogue = [];
let characterData = {};
let imageBase = '';
let index = 0, charIndex = 0, typing = false;
let autoUpdateInterval = null;
const preloadedImages = new Set(); // Prevents redundant downloads

const textbox = document.getElementById('textbox');
const namebox = document.getElementById('namebox');
const textEl = document.getElementById('text');
const portrait = document.getElementById('portrait');
const bg = document.getElementById('bg');

/** HELPERS **/
function resolvePath(candidate, baseForRelative) {
  if (!candidate) return candidate;
  if (/^https?:\/\//i.test(candidate)) return candidate;
  try {
    const base = baseForRelative || window.location.href;
    return new URL(candidate, base).toString();
  } catch (e) { return candidate; }
}

function deriveImageBase(path) {
  if (!path) return '';
  const lastSlash = path.lastIndexOf('/');
  return lastSlash >= 0 ? path.substring(0, lastSlash + 1) : '';
}

function preload(url) {
  if (!url || preloadedImages.has(url)) return;
  const img = new Image();
  img.src = url;
  preloadedImages.add(url);
}

/** CORE LOGIC **/
async function loadJSON(path) {
  const res = await fetch(path, { cache: "no-cache" });
  if (!res.ok) throw new Error('HTTP ' + res.status);
  return await res.json();
}

async function loadData() {
  try {
    imageBase = resolvePath(deriveImageBase(CHARACTERDATA_PATH));
    const [d, c] = await Promise.all([
      loadJSON(DIALOGUE_PATH),
      loadJSON(CHARACTERDATA_PATH)
    ]);

    dialogue = Array.isArray(d.dialogue) ? d.dialogue : (Array.isArray(d) ? d : []);
    characterData = c || {};

    if (dialogue.length > 0) {
      index = 0;
      // Pre-cache first background immediately
      if (dialogue[0].bg?.file) preload(resolvePath(dialogue[0].bg.file, imageBase));
      showTextbox();
    }
  } catch (err) {
    console.error('Initial load failed:', err);
    textEl.textContent = "Error loading assets. Check console.";
    textbox.style.display = 'block';
  }
}

function showTextbox() {
  textbox.style.display = 'block';
  startLine();
}

function startLine() {
  typing = true;
  charIndex = 0;
  textEl.textContent = '';
  const line = dialogue[index] || { name: '', text: '' };
  namebox.textContent = line.name || '';

  // 1. Current Portrait
  if (line.expression && characterData.list?.[line.expression]) {
    let entry = characterData.list[line.expression];
    if (typeof entry === 'object') entry = entry.file;
    if (!/(\.[a-zA-Z0-9]+)$/.test(entry)) entry += '.png';

    portrait.src = resolvePath(entry, imageBase);
    portrait.style.display = 'block';
  } else {
    portrait.style.display = 'none';
  }

  // 2. Current Background
  if (line.bg?.file) {
    bg.src = resolvePath(line.bg.file, imageBase);
    bg.style.objectFit = (line.bg.scaleMode?.toLowerCase() === 'fill') ? 'cover' : 'contain';
  }

  // 3. SMART PRELOAD (Look ahead one step)
  if (index + 1 < dialogue.length) {
    const nextLine = dialogue[index + 1];
    // Cache next expression
    if (nextLine.expression && characterData.list?.[nextLine.expression]) {
      let nextExp = characterData.list[nextLine.expression];
      if (typeof nextExp === 'object') nextExp = nextExp.file;
      if (!/(\.[a-zA-Z0-9]+)$/.test(nextExp)) nextExp += '.png';
      preload(resolvePath(nextExp, imageBase));
    }
    // Cache next background
    if (nextLine.bg?.file) {
      preload(resolvePath(nextLine.bg.file, imageBase));
    }
  }

  type();
}

function type() {
  const line = dialogue[index] || { text: '' };
  const fullText = line.text || '';
  if (charIndex < fullText.length) {
    textEl.textContent += fullText.charAt(charIndex++);
    textEl.scrollTop = textEl.scrollHeight;
    setTimeout(type, 30);
  } else {
    typing = false;
  }
}

function finishTyping() {
  const line = dialogue[index] || { text: '' };
  textEl.textContent = line.text || '';
  typing = false;
}

function nextLine() {
  if (typing) { finishTyping(); return; }
  index++;
  if (index < dialogue.length) {
    startLine();
  } else {
    textbox.style.display = 'none';
    portrait.style.display = 'none';
  }
}

/** LISTENERS **/
document.addEventListener('click', (e) => {
  if (textbox.style.display !== 'none') nextLine();
});

document.addEventListener('keydown', (e) => {
  if (textbox.style.display === 'none') return;
  if (e.key === ' ' || e.key === 'Enter') {
    e.preventDefault();
    nextLine();
  }
});

// Auto-update check for remote JSON
if (/^https?:\/\//i.test(DIALOGUE_PATH)) {
  setInterval(async () => {
    try {
      const d = await loadJSON(DIALOGUE_PATH);
      dialogue = Array.isArray(d.dialogue) ? d.dialogue : (Array.isArray(d) ? d : []);
    } catch(e) {}
  }, 60000);
}

loadData();
</script>
</body>
</html>
