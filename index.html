<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Pro DDLC Textbox (JSON + Character Packs + BGS)</title>
<style>
  :root {
    --textbox-width: 900px;
    --textbox-height: 200px;
    --accent: #f6a5c0;
    --bg-color: #111;
    --text-color: #222;
  }
  html,body { height:100%; margin:0; background:var(--bg-color); color:#fff; font-family: Arial, sans-serif; }
  #scene { position: relative; width: 100vw; height: 100vh; overflow: hidden; }
  #bg {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
    z-index: 0;
    user-select: none;
    pointer-events: none;
    filter: brightness(0.95);
    background: #000;
  }
  #portrait {
    position: absolute;
    right: 40px;
    bottom: 120px;
    width: 28vw;
    max-width: 420px;
    min-width: 160px;
    z-index: 2;
    display: none;
    user-select: none;
    pointer-events: none;
  }
  #textbox {
    position: fixed;
    bottom: 0;
    left: 50%;
    transform: translateX(-50%);
    width: var(--textbox-width);
    max-width: calc(100vw - 40px);
    height: var(--textbox-height);
    max-height: 50vh;
    background: #fff;
    border-top: 6px solid var(--accent);
    box-shadow: 0 -5px 25px rgba(0,0,0,0.4);
    border-radius: 10px 10px 0 0;
    padding: 18px 22px;
    box-sizing: border-box;
    display: none;
    color: var(--text-color);
    z-index: 3;
  }
  #namebox {
    position: absolute;
    top: -36px;
    left: 20px;
    background: var(--accent);
    color: white;
    padding: 8px 16px;
    font-weight: bold;
    border-radius: 6px 6px 0 0;
    min-width: 80px;
    box-sizing: border-box;
  }
  #text { font-size: 22px; color: var(--text-color); line-height: 1.4; white-space: pre-wrap; word-break: break-word; max-height: calc(var(--textbox-height) - 60px); overflow:auto; }
  #next { position: absolute; bottom: 10px; right: 20px; font-size: 14px; opacity: 0.75; color: var(--text-color); user-select:none; }
  @media (max-width: 600px) {
    #portrait { display: none; }
    #text { font-size: 18px; }
  }
</style>
</head>
<body>

<div id="scene" aria-hidden="false">
  <img id="bg" alt="background" />
  <img id="portrait" alt="character portrait" />
</div>

<div id="textbox" role="region" aria-label="dialogue textbox" aria-live="polite">
  <div id="namebox" aria-hidden="true"></div>
  <div id="text" aria-atomic="false"></div>
  <div id="next">â–¶ Click or press Space/Enter</div>
</div>

<script>
/*
  Notes:
  - Place your JSON at assets/dialogue.json by default.
  - Place character packs at assets/characters/... by default.
  - characterdata.list entries can be:
      - full URL ("https://.../portrait.png")
      - relative path ("portraits/portrait1.png")
      - filename without ext ("portrait1") -> .png will be appended
  - dialogue entries may include:
      { name: "Name", expression: "idle", text: "Hello", bg: { file: "assets/bg.png", scaleMode: "fill" } }
*/

let dialogue = [];
let characterData = {};
let imageBase = '';
let index = 0, charIndex = 0, typing = false;
let autoUpdateInterval = null;

const textbox = document.getElementById('textbox');
const namebox = document.getElementById('namebox');
const textEl = document.getElementById('text');
const portrait = document.getElementById('portrait');
const bg = document.getElementById('bg');

// EDIT THESE PATHS as needed (default: relative to this HTML)
const DIALOGUE_PATH = 'assets/dialogue.json'; // can be a remote raw URL too
const CHARACTERDATA_PATH = 'assets/characters/katz/characterdata.json'; // path or URL

// Helper resolve function: accepts absolute URLs, absolute paths, or relative paths and returns absolute URL
function resolvePath(candidate, baseForRelative) {
  if (!candidate) return candidate;
  // If it's already an absolute URL
  if (/^https?:\/\//i.test(candidate)) return candidate;
  try {
    // If candidate is root-anchored (starts with /), resolve against origin
    if (candidate.startsWith('/')) {
      return new URL(candidate, window.location.origin).toString();
    }
    // Otherwise resolve relative to provided base or page location
    const base = baseForRelative || window.location.href;
    return new URL(candidate, base).toString();
  } catch (e) {
    // Fallback: return candidate as-is
    return candidate;
  }
}

function deriveImageBase(characterPath) {
  // Return a base URL to resolve relative image entries
  if (!characterPath) return '';
  if (/^https?:\/\//i.test(characterPath)) {
    try {
      const url = new URL(characterPath);
      url.pathname = url.pathname.substring(0, url.pathname.lastIndexOf('/') + 1);
      return url.toString();
    } catch (e) {
      return '';
    }
  } else {
    // relative path: get directory part and resolve against current document
    const lastSlash = characterPath.lastIndexOf('/');
    const dir = lastSlash >= 0 ? characterPath.substring(0, lastSlash + 1) : '';
    return dir ? new URL(dir, window.location.href).toString() : window.location.href;
  }
}

async function loadJSON(path) {
  try {
    const res = await fetch(path, { cache: "no-cache" });
    if (!res.ok) throw new Error('HTTP ' + res.status + ' loading ' + path);
    return await res.json();
  } catch (err) {
    throw err;
  }
}

async function loadData() {
  try {
    // derive imageBase right away (works for both relative and absolute character path)
    imageBase = deriveImageBase(CHARACTERDATA_PATH);

    // Load dialogue and character data in parallel when possible
    const [d, c] = await Promise.all([
      loadJSON(DIALOGUE_PATH),
      loadJSON(CHARACTERDATA_PATH)
    ]);

    dialogue = Array.isArray(d.dialogue) ? d.dialogue : (Array.isArray(d) ? d : []);
    characterData = c || {};

    // start if any lines
    if (dialogue.length > 0) {
      index = 0;
      showTextbox();
    } else {
      // Nothing to show: hide
      textbox.style.display = 'none';
      portrait.style.display = 'none';
      console.info('No dialogue found in', DIALOGUE_PATH);
    }
  } catch (err) {
    console.error('loadData error:', err);
    namebox.textContent = 'Error';
    textEl.textContent = 'Failed to load dialogue or character data. Check console for details.';
    textbox.style.display = 'block';
  }
}

function showTextbox() {
  textbox.style.display = 'block';
  textbox.focus?.();
  startLine();
}

function startLine() {
  typing = true;
  charIndex = 0;
  textEl.textContent = '';
  const line = dialogue[index] || { name: '', text: '' };
  namebox.textContent = line.name || '';

  // handle portrait / expression
  if (line.expression && characterData.list && characterData.list[line.expression]) {
    let entry = characterData.list[line.expression];
    // If entry is an object with file property, allow that too
    if (typeof entry === 'object' && entry.file) entry = entry.file;

    // If entry has an extension, use as-is; otherwise append .png
    if (!/(\.[a-zA-Z0-9]+)$/.test(entry)) {
      entry = entry + '.png';
    }

    // Resolve path: if entry is absolute URL, use it; otherwise resolve relative to imageBase
    portrait.src = resolvePath(entry, imageBase);
    portrait.style.display = 'block';
    portrait.onload = () => { portrait.style.display = 'block'; };
    portrait.onerror = () => {
      console.warn('Failed to load portrait:', portrait.src);
      portrait.style.display = 'none';
    };
  } else {
    portrait.style.display = 'none';
    portrait.src = '';
  }

  // handle background
  if (line.bg && line.bg.file) {
    const bgFile = line.bg.file;
    const resolved = resolvePath(bgFile, imageBase);
    bg.src = resolved;
    bg.style.objectFit = (line.bg.scaleMode && line.bg.scaleMode.toLowerCase() === 'fill') ? 'cover' : 'contain';
    bg.onerror = () => { console.warn('Failed to load background:', bg.src); bg.src = ''; };
  } else {
    // keep current bg if you want continuity, or clear to none:
    // bg.src = '';
  }

  type();
}

function type() {
  const line = dialogue[index] || { text: '' };
  const text = line.text || '';
  if (charIndex < text.length) {
    // handle basic markup for pauses / newlines if needed in future
    textEl.textContent += text.charAt(charIndex++);
    // scroll text element if overflow
    textEl.scrollTop = textEl.scrollHeight;
    setTimeout(type, 30);
  } else {
    typing = false;
    // done typing, optionally flash or show next indicator
  }
}

function finishTyping() {
  const line = dialogue[index] || { text: '' };
  textEl.textContent = line.text || '';
  textEl.scrollTop = textEl.scrollHeight;
  typing = false;
}

function nextLine() {
  if (textbox.style.display === 'none') return; // do nothing if hidden
  if (dialogue.length === 0) return;
  if (typing) { finishTyping(); return; }
  index++;
  if (index < dialogue.length) startLine();
  else {
    // End of dialogue
    textbox.style.display = 'none';
    portrait.style.display = 'none';
    // remove listeners to avoid leaks
    document.removeEventListener('click', onDocClick);
    document.removeEventListener('keydown', onKeyDown);
    if (autoUpdateInterval) clearInterval(autoUpdateInterval);
  }
}

// Click handler only advances while textbox visible
function onDocClick(e) {
  // allow clicks anywhere while textbox visible
  if (textbox.style.display !== 'none') nextLine();
}

// Keyboard navigation
function onKeyDown(e) {
  if (textbox.style.display === 'none') return;
  if (e.key === ' ' || e.key === 'Enter') {
    e.preventDefault();
    nextLine();
  } else if (e.key === 'Escape') {
    // close/hide
    textbox.style.display = 'none';
    portrait.style.display = 'none';
    document.removeEventListener('click', onDocClick);
    document.removeEventListener('keydown', onKeyDown);
    if (autoUpdateInterval) clearInterval(autoUpdateInterval);
  }
}

// attach listeners
document.addEventListener('click', onDocClick);
document.addEventListener('keydown', onKeyDown);

// initial load
loadData();

// Optional: If you want auto-reload from a remote source, enable interval.
// Only enable when DIALOGUE_PATH is a remote URL (http/https).
try {
  if (/^https?:\/\//i.test(DIALOGUE_PATH)) {
    autoUpdateInterval = setInterval(loadData, 60000);
  }
} catch (e) { /* ignore */ }

</script>
</body>
</html>
// Optional: Auto-update every 60 seconds from GitHub
setInterval(loadData, 60000);
</script>
</body>
</html>
